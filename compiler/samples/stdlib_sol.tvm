	.internal-alias :main_internal,      0
	.internal-alias :general_purpose,    1


	.selector
	; s0 - func_id
	; s1.. - other data
	PRINTSTR selector
	SETCP0
	PUSHREFSLICE        ; dictionary of methods in first reference
	PLDDICT
	OVER
	NEQINT 1
	PUSHCONT {          ; if func_id negative or zero - direct call to method
		PUSHINT 32
		PRINTSTR selector_jmp_0
		DICTIGETJMP     ; execute method and return
	}
	PUSHCONT {          ; get dictionary with methods
		PUSHINT 32
		DICTIGETREF
		THROWIFNOT 52   ; no dictionary of methods
		PUSHINT 32
		PRINTSTR selector_jmp
		DICTUGETJMP     ; execute method and return
		THROW 51
	}
	IFELSE

	.internal   :main_internal
	PUSHINT $main_internal_body$
	CALL 1
	IFRET
	CALL 1 ;public method call
	RET


				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				;;; THE CODE BELOW IS GENERATED. DO NOT CHANGE IT!

.globl	encode_array
.type	encode_array, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: encode_array
;; param: builder
;; param: array
PRINTSTR encode_array
;; array
;; stack=2
DUP
PUSHINT 32
DICTUMAX
PUSHCONT { POP s1 INC }
PUSHCONT { PUSHINT 0 }
IFELSE
;; decl: len
;; len
;; stack=3
DUP
;; builder
;; stack=4
PUSH s3
STU 32
POP s3
;; array
;; stack=3
PUSH s1
;; builder
;; stack=4
PUSH s3
STDICT
POP s3
;; builder
;; stack=3
PUSH s2
;; return
XCHG s3
BLKDROP 3
RET

.globl	decode_array
.type	decode_array, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: decode_array
;; param: slice
PRINTSTR decode_array
;; if
;; slice
;; stack=1
DUP
SDEMPTY
PUSHCONT {
	;; slice
	;; stack=1
	DUP
	LDREF
	POP s2
	;; decl: refcell
	;; refcell
	;; stack=2
	DUP
	CTOS
	;; assign slice
	POP s2
	;; drop locals
	DROP
}
IF
;; slice
;; stack=1
DUP
LDU 32
POP s2
;; decl: len
;; slice
;; stack=2
PUSH s1
LDDICT
POP s3
;; decl: array
;; array
;; stack=3
DUP
PUSHINT 32
DICTUMAX
PUSHCONT { POP s1 INC }
PUSHCONT { PUSHINT 0 }
IFELSE
;; decl: len_actual
;; len
;; stack=4
PUSH s2
;; len_actual
;; stack=5
PUSH s1
;; ==
EQUAL
THROWIFNOT 100
PRINTSTR decode_array_ok
;; array
;; stack=4
PUSH s1
;; slice
;; stack=5
PUSH s4
;; return
BLKSWAP 4, 2
BLKDROP 4
RET

.globl	load_slice_from_two_cell
.type	load_slice_from_two_cell, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: load_slice_from_two_cell
;; param: slice
;; param: bitQty0
;; param: bitQty1
;; slice
;; stack=3
PUSH s2
;; bitQty0
;; stack=4
PUSH s2
LDSLICEX
POP s4
;; decl: sliceValue0
;; slice
;; stack=4
PUSH s3
LDREF
POP s5
;; decl: nextCell
;; slice
;; stack=5
PUSH s4
ENDS
NULL
POP s5
;; nextCell
;; stack=5
DUP
CTOS
;; assign slice
POP s5
;; slice
;; stack=5
PUSH s4
;; bitQty1
;; stack=6
PUSH s3
LDSLICEX
POP s6
;; decl: sliceValue1
NEWC
;; decl: numberBuilder
;; sliceValue0
;; stack=7
PUSH s3
STSLICER
;; sliceValue1
;; stack=7
PUSH s1
STSLICER
;; numberBuilder
;; stack=7
DUP
ENDC
CTOS
;; slice
;; stack=8
PUSH s7
;; return
BLKSWAP 7, 2
BLKDROP 7
RET

.globl	abi_encode_packed
.type	abi_encode_packed, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: abi_encode_packed
;; param: builder
;; param: array
;; param: bitSizeOfArrayElement
;; array
;; stack=3
PUSH s1
PUSHINT 32
DICTUMAX
PUSHCONT { POP s1 INC }
PUSHCONT { PUSHINT 0 }
IFELSE
;; decl: arraySize
; for statement
PUSHINT 0
;; decl: idx
PUSHCONT {
	;; idx
	;; stack=5
	DUP
	;; arraySize
	;; stack=6
	PUSH s2
	;; <
	LESS
	NOT DUP IFRET DROP
	;; m_isUntil = 1
	;; bitSizeOfArrayElement
	;; stack=5
	PUSH s2
	;; idx
	;; stack=6
	PUSH s1
	;; array
	;; stack=7
	PUSH s5
	PUSHINT 32
	DICTUGET
	PUSHCONT { 
		NIP
	}
	PUSHCONT {
		NEWC      ; valueBits builder
		PUSHINT 0 ; valueBits builder 0
		XCHG S2   ; 0 builder valueBits
		STUX      ; builder
		ENDC      ; cell
		CTOS      ; default_value
	}
	IFELSE
	;; decl: data_slice
	;; data_slice
	;; stack=6
	DUP
	;; builder
	;; stack=7
	PUSH s6
	STSLICE
	POP s6
	;; drop locals
	DROP
	;; ++
	INC
	FALSE
}
UNTIL
; erase idx
DROP
; for end
;; builder
;; stack=4
PUSH s3
;; return
XCHG s4
BLKDROP 4
RET

.globl	smart_ldi
.type	smart_ldi, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: smart_ldi
;; param: slice
;; param: bits
;; slice
;; stack=2
PUSH s1
SBITS ; tvm_sbits
;; decl: remBits
;; if
;; remBits
;; stack=3
DUP
;; bits
;; stack=4
PUSH s2
;; >=
GEQ
PUSHCONT {
	;; slice
	;; stack=3
	PUSH s2
	;; bits
	;; stack=4
	PUSH s2
	LDIX
	POP s4
	;; decl: number
	;; number
	;; stack=4
	DUP
	;; slice
	;; stack=5
	PUSH s4
	;; return
	BLKSWAP 4, 2
	BLKDROP 4
	RET
}
IFJMP
;; slice
;; stack=3
PUSH s2
;; remBits
;; stack=4
PUSH s1
LDSLICEX
POP s4
;; decl: sliceVal0
;; slice
;; stack=4
PUSH s3
LDREF
POP s5
;; decl: newCell
;; slice
;; stack=5
PUSH s4
ENDS
NULL
POP s5
;; newCell
;; stack=5
DUP
CTOS
;; decl: newSlice
;; newSlice
;; stack=6
DUP
;; bits
;; stack=7
PUSH s5
;; remBits
;; stack=8
PUSH s5
;; -
SUB
LDSLICEX
POP s2
;; decl: sliceVal1
NEWC
;; decl: numberBuilderOrSlice
;; sliceVal0
;; stack=8
PUSH s4
STSLICER
;; sliceVal1
;; stack=8
PUSH s1
STSLICER
;; numberBuilderOrSlice
;; stack=8
DUP
ENDC
CTOS
;; assign numberBuilderOrSlice
NIP
;; numberBuilderOrSlice
;; stack=8
DUP
;; bits
;; stack=9
PUSH s7
LDIX
POP s2
;; decl: number
;; number
;; stack=9
DUP
;; newSlice
;; stack=10
PUSH s4
;; return
BLKSWAP 9, 2
BLKDROP 9
RET

.globl	smart_ldu
.type	smart_ldu, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: smart_ldu
;; param: slice
;; param: bits
;; slice
;; stack=2
PUSH s1
SBITS ; tvm_sbits
;; decl: remBits
;; if
;; remBits
;; stack=3
DUP
;; bits
;; stack=4
PUSH s2
;; >=
GEQ
PUSHCONT {
	;; slice
	;; stack=3
	PUSH s2
	;; bits
	;; stack=4
	PUSH s2
	LDUX
	POP s4
	;; decl: number
	;; number
	;; stack=4
	DUP
	;; slice
	;; stack=5
	PUSH s4
	;; return
	BLKSWAP 4, 2
	BLKDROP 4
	RET
}
IFJMP
;; slice
;; stack=3
PUSH s2
;; remBits
;; stack=4
PUSH s1
LDSLICEX
POP s4
;; decl: sliceVal0
;; slice
;; stack=4
PUSH s3
LDREF
POP s5
;; decl: newCell
;; slice
;; stack=5
PUSH s4
ENDS
NULL
POP s5
;; newCell
;; stack=5
DUP
CTOS
;; decl: newSlice
;; newSlice
;; stack=6
DUP
;; bits
;; stack=7
PUSH s5
;; remBits
;; stack=8
PUSH s5
;; -
SUB
LDSLICEX
POP s2
;; decl: sliceVal1
NEWC
;; decl: numberBuilderOrSlice
;; sliceVal0
;; stack=8
PUSH s4
STSLICER
;; sliceVal1
;; stack=8
PUSH s1
STSLICER
;; numberBuilderOrSlice
;; stack=8
DUP
ENDC
CTOS
;; assign numberBuilderOrSlice
NIP
;; numberBuilderOrSlice
;; stack=8
DUP
;; bits
;; stack=9
PUSH s7
LDUX
POP s2
;; decl: number
;; number
;; stack=9
DUP
;; newSlice
;; stack=10
PUSH s4
;; return
BLKSWAP 9, 2
BLKDROP 9
RET

.globl	deploy_contract_without_constructor_params
.type	deploy_contract_without_constructor_params, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: deploy_contract_without_constructor_params
;; param: my_contract
;; param: remote_addr
;; param: grams_value
PRINTSTR deploy_contract
NEWC
;; decl: msg_builder
;; grams_value
;; stack=4
PUSH s1
;; remote_addr
;; stack=5
PUSH s3
PUSHINT 0
PUSHCONT { ; make__CommonMsgInfoRelaxed__int_msg_info_0__inline
	;; param: value
	;; param: remote_addr
	;; param: bounce
	PRINTSTR buildmsg
	NEWC
	;; decl: builder
	PUSHINT 2
	STZEROES
	;; bounce
	;; stack=4
	PUSH s1
	STIR 1
	PUSHINT 1
	STZEROES
	MYADDR
	STSLICER
	PUSHINT 1024
	STUR 11
	;; remote_addr
	;; stack=4
	PUSH s2
	STUR 256
	;; value
	;; stack=4
	PUSH s3
	STGRAMS
	PUSHINT 1
	STZEROES
	PUSHINT 0
	STGRAMS
	PUSHINT 0
	STGRAMS
	PUSHINT 64
	STZEROES
	NOW
	STUR 32
	PRINTSTR buildmsg_end
	;; builder
	;; stack=4
	DUP
	ENDC
	;; return
	XCHG s4
	BLKDROP 4
	RET
}
CALLX
;; decl: info
;; info
;; stack=5
DUP
CTOS
;; msg_builder
;; stack=6
PUSH s2
STSLICE
POP s2
;; msg_builder
;; stack=5
PUSH s1
PUSHINT 1
STONES
POP s2
;; msg_builder
;; stack=5
PUSH s1
;; my_contract
;; stack=6
PUSH s5
PUSHCONT { ; store_either_inline
	;; param: builder
	;; param: slice
	PRINTSTR store_either
	;; if
	;; builder
	;; stack=2
	PUSH s1
	BREMBITS ; tvm_brembits
	;; slice
	;; stack=3
	PUSH s1
	SBITS ; tvm_sbits
	PUSHINT 1
	;; +
	ADD
	;; >
	GREATER
	PUSHCONT {
		PUSHINT 0
		;; builder
		;; stack=3
		PUSH s2
		STU 1
		POP s2
		;; slice
		;; stack=2
		DUP
		;; builder
		;; stack=3
		PUSH s2
		STSLICE
		POP s2
	}
	PUSHCONT {
		PUSHINT 1
		;; builder
		;; stack=3
		PUSH s2
		STU 1
		POP s2
		;; slice
		;; stack=2
		DUP
		;; builder
		;; stack=3
		PUSH s2
		STSLICER
		POP s2
	}
	IFELSE
	;; builder
	;; stack=2
	PUSH s1
	;; return
	NIP
	NIP
	RET
}
CALLX
;; assign msg_builder
POP s2
PUSHINT $make_abi_and_constructorId$
CALL 1
;; decl: body
;; msg_builder
;; stack=6
PUSH s2
;; body
;; stack=7
PUSH s1
PUSHCONT { ; store_either_inline
	;; param: builder
	;; param: slice
	PRINTSTR store_either
	;; if
	;; builder
	;; stack=2
	PUSH s1
	BREMBITS ; tvm_brembits
	;; slice
	;; stack=3
	PUSH s1
	SBITS ; tvm_sbits
	PUSHINT 1
	;; +
	ADD
	;; >
	GREATER
	PUSHCONT {
		PUSHINT 0
		;; builder
		;; stack=3
		PUSH s2
		STU 1
		POP s2
		;; slice
		;; stack=2
		DUP
		;; builder
		;; stack=3
		PUSH s2
		STSLICE
		POP s2
	}
	PUSHCONT {
		PUSHINT 1
		;; builder
		;; stack=3
		PUSH s2
		STU 1
		POP s2
		;; slice
		;; stack=2
		DUP
		;; builder
		;; stack=3
		PUSH s2
		STSLICER
		POP s2
	}
	IFELSE
	;; builder
	;; stack=2
	PUSH s1
	;; return
	NIP
	NIP
	RET
}
CALLX
;; assign msg_builder
POP s3
;; msg_builder
;; stack=6
PUSH s2
ENDC
;; decl: message
;; message
;; stack=7
DUP
PUSHINT 0
SENDRAWMSG
BLKDROP 7

.globl	make_abi_and_constructorId
.type	make_abi_and_constructorId, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: make_abi_and_constructorId
PRINTSTR st_abi_n_constr
NEWC
;; decl: builder
PUSHINT $constructor$
STUR 32
;; builder
;; stack=1
DUP
ENDC
CTOS
;; return
NIP
RET

.globl	insert_pubkey
.type	insert_pubkey, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: insert_pubkey
;; param: my_contract
;; param: pubkey
;; my_contract
;; stack=2
PUSH s1
CTOS
;; decl: slice
NEWC
;; decl: builder
PUSHINT 0
;; decl: maybe
;; slice
;; stack=5
PUSH s2
LDU 32
POP s4
;; builder
;; stack=6
PUSH s2
STU 32
POP s2
;; slice
;; stack=5
PUSH s2
LDU 1
POP s4
;; assign maybe
NIP
;; maybe
;; stack=5
DUP
;; builder
;; stack=6
PUSH s2
STU 1
POP s2
;; if
;; maybe
;; stack=5
DUP
PUSHINT 1
;; ==
EQUAL
PUSHCONT {
	;; slice
	;; stack=5
	PUSH s2
	LDU 2
	POP s4
	;; builder
	;; stack=6
	PUSH s2
	STU 2
	POP s2
}
IF
;; slice
;; stack=5
PUSH s2
LDU 1
POP s4
;; assign maybe
NIP
;; maybe
;; stack=5
DUP
;; builder
;; stack=6
PUSH s2
STU 1
POP s2
;; if
;; maybe
;; stack=5
DUP
PUSHINT 1
;; ==
EQUAL
PUSHCONT {
	;; slice
	;; stack=5
	PUSH s2
	LDREF
	POP s4
	;; decl: code
	;; code
	;; stack=6
	DUP
	CTOS
	;; builder
	;; stack=7
	PUSH s3
	STSLICER
	POP s3
	;; drop locals
	DROP
}
IF
;; slice
;; stack=5
PUSH s2
LDU 1
POP s4
;; assign maybe
NIP
;; maybe
;; stack=5
DUP
;; builder
;; stack=6
PUSH s2
STU 1
POP s2
;; maybe
;; stack=5
DUP
PUSHINT 1
;; ==
EQUAL
THROWIFNOT 100
PUSHINT 0
;; decl: tmp_builder
NEWC
;; assign tmp_builder
NIP
;; pubkey
;; stack=6
PUSH s4
STUR 256
;; tmp_builder
;; stack=6
DUP
ENDC
CTOS
;; decl: slice_pubkey
;; slice
;; stack=7
PUSH s4
LDREF
POP s6
CTOS
;; decl: slice_data
;; slice_data
;; stack=8
DUP
LDDICT
POP s2
;; decl: dict
;; slice_pubkey
;; stack=9
PUSH s2
PUSHINT 0
;; dict
;; stack=11
PUSH s2
PUSHINT 64
DICTUSET
NIP
NEWC
;; assign tmp_builder
POP s4
;; dict
;; stack=9
DUP
;; tmp_builder
;; stack=10
PUSH s4
STDICT
POP s4
;; slice
;; stack=9
PUSH s6
LDU 1
POP s8
;; assign maybe
POP s5
;; maybe
;; stack=9
PUSH s4
;; builder
;; stack=10
PUSH s6
STU 1
POP s6
;; if
;; maybe
;; stack=9
PUSH s4
PUSHINT 1
;; ==
EQUAL
PUSHCONT {
	;; slice
	;; stack=9
	PUSH s6
	LDREF
	POP s8
	;; decl: lib
	;; lib
	;; stack=10
	DUP
	CTOS
	;; builder
	;; stack=11
	PUSH s7
	STSLICER
	POP s7
	;; drop locals
	DROP
}
IF
;; builder
;; stack=9
PUSH s5
ENDC
;; return
XCHG s9
BLKDROP 9
RET

.globl	send_int_msg
.type	send_int_msg, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: send_int_msg
;; param: 
;; param: body_slice
;; param: remote_addr
;; param: grams_value
PRINTSTR send_int_msg
NEWC
;; decl: msg_builder
;; grams_value
;; stack=5
PUSH s1
;; remote_addr
;; stack=6
PUSH s3
;; -
PUSHINT 1
NEGATE
PUSHCONT { ; make__CommonMsgInfoRelaxed__int_msg_info_0__inline
	;; param: value
	;; param: remote_addr
	;; param: bounce
	PRINTSTR buildmsg
	NEWC
	;; decl: builder
	PUSHINT 2
	STZEROES
	;; bounce
	;; stack=4
	PUSH s1
	STIR 1
	PUSHINT 1
	STZEROES
	MYADDR
	STSLICER
	PUSHINT 1024
	STUR 11
	;; remote_addr
	;; stack=4
	PUSH s2
	STUR 256
	;; value
	;; stack=4
	PUSH s3
	STGRAMS
	PUSHINT 1
	STZEROES
	PUSHINT 0
	STGRAMS
	PUSHINT 0
	STGRAMS
	PUSHINT 64
	STZEROES
	NOW
	STUR 32
	PRINTSTR buildmsg_end
	;; builder
	;; stack=4
	DUP
	ENDC
	;; return
	XCHG s4
	BLKDROP 4
	RET
}
CALLX
CTOS
STSLICER
PUSHINT 0
STUR 1
;; msg_builder
;; stack=5
DUP
;; body_slice
;; stack=6
PUSH s4
PUSHCONT { ; store_either_inline
	;; param: builder
	;; param: slice
	PRINTSTR store_either
	;; if
	;; builder
	;; stack=2
	PUSH s1
	BREMBITS ; tvm_brembits
	;; slice
	;; stack=3
	PUSH s1
	SBITS ; tvm_sbits
	PUSHINT 1
	;; +
	ADD
	;; >
	GREATER
	PUSHCONT {
		PUSHINT 0
		;; builder
		;; stack=3
		PUSH s2
		STU 1
		POP s2
		;; slice
		;; stack=2
		DUP
		;; builder
		;; stack=3
		PUSH s2
		STSLICE
		POP s2
	}
	PUSHCONT {
		PUSHINT 1
		;; builder
		;; stack=3
		PUSH s2
		STU 1
		POP s2
		;; slice
		;; stack=2
		DUP
		;; builder
		;; stack=3
		PUSH s2
		STSLICER
		POP s2
	}
	IFELSE
	;; builder
	;; stack=2
	PUSH s1
	;; return
	NIP
	NIP
	RET
}
CALLX
;; assign msg_builder
NIP
;; msg_builder
;; stack=5
DUP
ENDC
PUSHINT 0
SENDRAWMSG
BLKDROP 5

.globl	accurate_transfer
.type	accurate_transfer, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: accurate_transfer
;; param: remote_addr
;; param: grams_value
;; param: bounce
;; param: sendrawmsg_flag
PRINTSTR ac_transfer
NEWC
;; decl: builder
PUSHINT 2
STZEROES
;; bounce
;; stack=5
PUSH s2
STIR 1
PUSHINT 1
STZEROES
MYADDR
STSLICER
PUSHINT 1024
STUR 11
;; remote_addr
;; stack=5
PUSH s4
STUR 256
;; grams_value
;; stack=5
PUSH s3
STGRAMS
PUSHINT 1
STZEROES
PUSHINT 0
STGRAMS
PUSHINT 0
STGRAMS
PUSHINT 64
STZEROES
NOW
STUR 32
PUSHINT 2
STZEROES
;; builder
;; stack=5
DUP
ENDC
;; sendrawmsg_flag
;; stack=6
PUSH s2
SENDRAWMSG
PRINTSTR ac_transfer_end
BLKDROP 5

.globl	store_either_inline
.type	store_either_inline, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: store_either_inline
;; param: builder
;; param: slice
PRINTSTR store_either
;; if
;; builder
;; stack=2
PUSH s1
BREMBITS ; tvm_brembits
;; slice
;; stack=3
PUSH s1
SBITS ; tvm_sbits
PUSHINT 1
;; +
ADD
;; >
GREATER
PUSHCONT {
	PUSHINT 0
	;; builder
	;; stack=3
	PUSH s2
	STU 1
	POP s2
	;; slice
	;; stack=2
	DUP
	;; builder
	;; stack=3
	PUSH s2
	STSLICE
	POP s2
}
PUSHCONT {
	PUSHINT 1
	;; builder
	;; stack=3
	PUSH s2
	STU 1
	POP s2
	;; slice
	;; stack=2
	DUP
	;; builder
	;; stack=3
	PUSH s2
	STSLICER
	POP s2
}
IFELSE
;; builder
;; stack=2
PUSH s1
;; return
NIP
NIP
RET

.globl	make__CommonMsgInfoRelaxed__int_msg_info_0__inline
.type	make__CommonMsgInfoRelaxed__int_msg_info_0__inline, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: make__CommonMsgInfoRelaxed__int_msg_info_0__inline
;; param: value
;; param: remote_addr
;; param: bounce
PRINTSTR buildmsg
NEWC
;; decl: builder
PUSHINT 2
STZEROES
;; bounce
;; stack=4
PUSH s1
STIR 1
PUSHINT 1
STZEROES
MYADDR
STSLICER
PUSHINT 1024
STUR 11
;; remote_addr
;; stack=4
PUSH s2
STUR 256
;; value
;; stack=4
PUSH s3
STGRAMS
PUSHINT 1
STZEROES
PUSHINT 0
STGRAMS
PUSHINT 0
STGRAMS
PUSHINT 64
STZEROES
NOW
STUR 32
PRINTSTR buildmsg_end
;; builder
;; stack=4
DUP
ENDC
;; return
XCHG s4
BLKDROP 4
RET

.globl	put_in_dictionary_as_slice
.type	put_in_dictionary_as_slice, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: put_in_dictionary_as_slice
;; param: data
;; param: key
;; param: dictionary
;; param: bits
;; param: dataSize
NEWC
;; decl: builder
;; data
;; stack=6
PUSH s5
;; dataSize
;; stack=7
PUSH s2
STUXR
;; builder
;; stack=6
DUP
ENDC
CTOS
;; assign builder
NIP
;; builder
;; stack=6
DUP
;; key
;; stack=7
PUSH s5
;; dictionary
;; stack=8
PUSH s5
;; bits
;; stack=9
PUSH s5
DICTUSET
POP s4
;; dictionary
;; stack=6
PUSH s3
;; return
XCHG s6
BLKDROP 6
RET

.globl	store_signature_inline
.type	store_signature_inline, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: store_signature_inline
;; param: msg_balance
;; param: src_addr
;; param: sign
PRINTSTR store_sig
TUPLE 0
;; decl: tuple
;; sign
;; stack=4
PUSH s1
TPUSH
;; src_addr
;; stack=4
PUSH s2
TPUSH
;; msg_balance
;; stack=4
PUSH s3
TPUSH
PUSHCTR c7
;; decl: c7
;; tuple
;; stack=5
PUSH s1
TPUSH
;; c7
;; stack=5
DUP
POPCTR c7
PRINTSTR store_sig_end
BLKDROP 5

.globl	build_external_outbound_message
.type	build_external_outbound_message, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: build_external_outbound_message
;; param: body
;; param: logical_time
;; param: src_address
PRINTSTR build_ext_msg
NEWC
;; decl: builder
PUSHINT 3
STUR 2
;; src_address
;; stack=4
PUSH s1
STSLICER
PUSHINT 0
STUR 2
;; logical_time
;; stack=4
PUSH s2
STUR 64
PUSHINT 0
STUR 32
PUSHINT 0
STUR 1
;; builder
;; stack=4
DUP
BREMBITS ; tvm_brembits
;; decl: bits
;; body
;; stack=5
PUSH s4
SBITS ; tvm_sbits
PUSHINT 1
;; +
ADD
;; decl: body_bits
;; if
;; bits
;; stack=6
PUSH s1
;; body_bits
;; stack=7
PUSH s1
;; >
GREATER
PUSHCONT {
	PUSHINT 0
	;; builder
	;; stack=7
	PUSH s3
	STU 1
	POP s3
	;; body
	;; stack=6
	PUSH s5
	;; builder
	;; stack=7
	PUSH s3
	STSLICE
	POP s3
}
PUSHCONT {
	PUSHINT 1
	;; builder
	;; stack=7
	PUSH s3
	STU 1
	POP s3
	NEWC
	;; decl: builder2
	;; body
	;; stack=7
	PUSH s6
	STSLICER
	;; builder2
	;; stack=7
	DUP
	ENDC
	;; builder
	;; stack=8
	PUSH s4
	STREF
	POP s4
	;; drop locals
	DROP
}
IFELSE
;; builder
;; stack=6
PUSH s2
ENDC
;; return
XCHG s6
BLKDROP 6
RET

.globl	change_array_length
.type	change_array_length, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: change_array_length
;; param: slice
;; param: array
;; param: new_len
PRINTSTR change_arr_len
;; array
;; stack=3
PUSH s1
PUSHINT 32
DICTUMAX
PUSHCONT { POP s1 INC }
PUSHCONT { PUSHINT 0 }
IFELSE
;; decl: len
;; if
;; len
;; stack=4
DUP
;; new_len
;; stack=5
PUSH s2
;; >=
GEQ
PUSHCONT {
	; while statement
	PUSHCONT {
		;; len
		;; stack=4
		DUP
		;; new_len
		;; stack=5
		PUSH s2
		;; >
		GREATER
		NOT DUP IFRET DROP
		;; m_isUntil = 1
		;; --
		DEC
		;; len
		;; stack=4
		DUP
		;; array
		;; stack=5
		PUSH s3
		PUSHINT 32
		DICTUDEL
		DROP
		;; assign array
		POP s3
		FALSE
	}
	UNTIL
	; while end
}
PUSHCONT {
	;; if
	;; !
	;; slice
	;; stack=4
	PUSH s3
	ISNULL
	NOT
	PUSHCONT {
		;; slice
		;; stack=4
		PUSH s3
		;; new_len
		;; stack=5
		PUSH s2
		PUSHINT 1
		;; -
		SUB
		;; array
		;; stack=6
		PUSH s4
		PUSHINT 32
		DICTUSET
		POP s3
	}
	IF
}
IFELSE
PRINTSTR ch_arr_len_end
;; array
;; stack=4
PUSH s2
;; return
XCHG s4
BLKDROP 4
RET

.globl	send_grams
.type	send_grams, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: send_grams
;; param: grams_value
;; param: dst_addr
;; param: body_slice
PRINTSTR send_grams
PUSHINT 0
;; body_slice
;; stack=4
PUSH s1
;; dst_addr
;; stack=5
PUSH s3
;; grams_value
;; stack=6
PUSH s5
PUSHINT $send_int_msg$
CALL 1
BLKDROP 3

.globl	send_int_msg_2
.type	send_int_msg_2, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: send_int_msg_2
;; param: dst_addr
;; param: body_slice
PRINTSTR send_int_msg_2
PUSHINT 0
;; body_slice
;; stack=3
PUSH s1
;; dst_addr
;; stack=4
PUSH s3
PUSHINT 10_000_000
PUSHINT $send_int_msg$
CALL 1
BLKDROP 2

.globl	send_ext_msg
.type	send_ext_msg, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: send_ext_msg
;; param: body_slice
PRINTSTR send_ext_msg
LTIME
;; decl: ltime
MYADDR
;; decl: snd_addr
;; body_slice
;; stack=3
PUSH s2
;; ltime
;; stack=4
PUSH s2
;; snd_addr
;; stack=5
PUSH s2
PUSHINT $build_external_outbound_message$
CALL 1
;; decl: cell
;; cell
;; stack=4
DUP
PUSHINT 0
SENDRAWMSG
BLKDROP 4

.globl	get_self_address
.type	get_self_address, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_self_address
PRINTSTR get_self_addr
MYADDR
PUSHINT 11
PUSHCONT { ; get_address_from_slice_inline
	;; param: slice
	;; param: offset
	;; slice
	;; stack=2
	PUSH s1
	;; offset
	;; stack=3
	PUSH s1
	SDSKIPFIRST
	POP s2
	;; slice
	;; stack=2
	PUSH s1
	LDU 256
	POP s3
	;; return
	NIP
	NIP
	RET
}
CALLX
;; return
RET

.globl	get_address_from_slice_inline
.type	get_address_from_slice_inline, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_address_from_slice_inline
;; param: slice
;; param: offset
;; slice
;; stack=2
PUSH s1
;; offset
;; stack=3
PUSH s1
SDSKIPFIRST
POP s2
;; slice
;; stack=2
PUSH s1
LDU 256
POP s3
;; return
NIP
NIP
RET

.globl	get_rand_seed
.type	get_rand_seed, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_rand_seed
PRINTSTR get_rand_seed
GETPARAM 6
;; return
RET

.globl	get_contract_balance
.type	get_contract_balance, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_contract_balance
PRINTSTR get_balance
GETPARAM 7
FIRST
;; return
RET

.globl	get_src_addr_and_bounce__inline
.type	get_src_addr_and_bounce__inline, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_src_addr_and_bounce__inline
;; param: msg_cell
PRINTSTR get_src_addr
;; msg_cell
;; stack=1
DUP
CTOS
;; decl: msg_slice
;; if
;; msg_slice
;; stack=2
DUP
LDU 1
POP s2
PUSHINT 0
;; !=
NEQ
PUSHCONT {
	PUSHINT 0
	PUSHINT 0
	;; return
	BLKSWAP 2, 2
	BLKDROP 2
	RET
}
IFJMP
;; msg_slice
;; stack=2
DUP
PUSHINT 2
SDSKIPFIRST
NIP
;; msg_slice
;; stack=2
DUP
LDU 1
POP s2
;; decl: bounced
;; msg_slice
;; stack=3
PUSH s1
PUSHINT 11
PUSHCONT { ; get_address_from_slice_inline
	;; param: slice
	;; param: offset
	;; slice
	;; stack=2
	PUSH s1
	;; offset
	;; stack=3
	PUSH s1
	SDSKIPFIRST
	POP s2
	;; slice
	;; stack=2
	PUSH s1
	LDU 256
	POP s3
	;; return
	NIP
	NIP
	RET
}
CALLX
;; decl: addr
PRINTSTR get_src_addr_en
;; bounced
;; stack=4
PUSH s1
;; addr
;; stack=5
PUSH s1
;; return
BLKSWAP 4, 2
BLKDROP 4
RET

.globl	get_msg_pubkey_inline
.type	get_msg_pubkey_inline, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: get_msg_pubkey_inline
;; param: msg_slice
PRINTSTR get_msg_pubkey
PUSHINT 0
;; decl: pubKey
;; if
;; msg_slice
;; stack=2
PUSH s1
SREMPTY
PUSHCONT {
	;; m_addReturnFlag = 1
	PRINTSTR get_msg_pubkey3
	PUSHINT 0
	;; return
	NIP
	NIP
	PUSHINT 1 ; return
	RET
}
PUSHCONT {
	;; m_addReturnFlag = 1
	;; msg_slice
	;; stack=2
	PUSH s1
	LDREFRTOS
	;; decl: rest_msg_slice
	;; decl: slice
	;; if
	;; slice
	;; stack=4
	DUP
	SDEMPTY
	PUSHCONT {
		;; m_addReturnFlag = 1
		PRINTSTR get_msg_pubkey3
		PUSHINT 0
		;; return
		XCHG s4
		BLKDROP 4
		PUSHINT 1 ; return
		RET
	}
	IFJMP
	;; slice
	;; stack=4
	DUP
	PUSHINT 512
	PUSHCONT { ; get_address_from_slice_inline
		;; param: slice
		;; param: offset
		;; slice
		;; stack=2
		PUSH s1
		;; offset
		;; stack=3
		PUSH s1
		SDSKIPFIRST
		POP s2
		;; slice
		;; stack=2
		PUSH s1
		LDU 256
		POP s3
		;; return
		NIP
		NIP
		RET
	}
	CALLX
	;; assign pubKey
	POP s3
	;; rest_msg_slice
	;; stack=4
	PUSH s1
	HASHSU
	;; decl: hash
	;; hash
	;; stack=5
	DUP
	;; slice
	;; stack=6
	PUSH s2
	;; pubKey
	;; stack=7
	PUSH s5
	CHKSIGNU
	;; decl: checkSig
	;; checkSig
	;; stack=6
	DUP
	THROWIFNOT 40
	;; drop locals
	BLKDROP 4
	FALSE
}
IFELSE
IFRET
PRINTSTR get_msg_pubkey2
;; pubKey
;; stack=2
DUP
;; return
NIP
NIP
RET

.globl	main_internal_body
.type	main_internal_body, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: main_internal_body
;; param: 
;; param: msg_balance
;; param: msg_cell
;; param: msg_body_slice
ACCEPT
PRINTSTR main_internal
;; msg_cell
;; stack=4
PUSH s1
PUSHCONT { ; get_src_addr_and_bounce__inline
	;; param: msg_cell
	PRINTSTR get_src_addr
	;; msg_cell
	;; stack=1
	DUP
	CTOS
	;; decl: msg_slice
	;; if
	;; msg_slice
	;; stack=2
	DUP
	LDU 1
	POP s2
	PUSHINT 0
	;; !=
	NEQ
	PUSHCONT {
		PUSHINT 0
		PUSHINT 0
		;; return
		BLKSWAP 2, 2
		BLKDROP 2
		RET
	}
	IFJMP
	;; msg_slice
	;; stack=2
	DUP
	PUSHINT 2
	SDSKIPFIRST
	NIP
	;; msg_slice
	;; stack=2
	DUP
	LDU 1
	POP s2
	;; decl: bounced
	;; msg_slice
	;; stack=3
	PUSH s1
	PUSHINT 11
	PUSHCONT { ; get_address_from_slice_inline
		;; param: slice
		;; param: offset
		;; slice
		;; stack=2
		PUSH s1
		;; offset
		;; stack=3
		PUSH s1
		SDSKIPFIRST
		POP s2
		;; slice
		;; stack=2
		PUSH s1
		LDU 256
		POP s3
		;; return
		NIP
		NIP
		RET
	}
	CALLX
	;; decl: addr
	PRINTSTR get_src_addr_en
	;; bounced
	;; stack=4
	PUSH s1
	;; addr
	;; stack=5
	PUSH s1
	;; return
	BLKSWAP 4, 2
	BLKDROP 4
	RET
}
CALLX
;; decl: bounced
;; decl: src_addr
;; msg_balance
;; stack=6
PUSH s4
;; src_addr
;; stack=7
PUSH s1
PUSHINT 0
PUSHCONT { ; store_signature_inline
	;; param: msg_balance
	;; param: src_addr
	;; param: sign
	PRINTSTR store_sig
	TUPLE 0
	;; decl: tuple
	;; sign
	;; stack=4
	PUSH s1
	TPUSH
	;; src_addr
	;; stack=4
	PUSH s2
	TPUSH
	;; msg_balance
	;; stack=4
	PUSH s3
	TPUSH
	PUSHCTR c7
	;; decl: c7
	;; tuple
	;; stack=5
	PUSH s1
	TPUSH
	;; c7
	;; stack=5
	DUP
	POPCTR c7
	PRINTSTR store_sig_end
	BLKDROP 5
}
CALLX
;; if
;; msg_body_slice
;; stack=6
PUSH s2
SEMPTY
PUSHCONT {
	;; if
	;; bounced
	;; stack=6
	PUSH s1
	PUSHINT 0
	;; ==
	EQUAL
	PUSHCONT {
		PUSHINT $fallback$
		;; decl: id_fun
		PUSHINT 0
		;; id_fun
		;; stack=8
		PUSH s1
		PUSHINT 0
		;; return
		BLKSWAP 7, 3
		BLKDROP 7
		RET
	}
	IFJMP
	PUSHINT 0
	PUSHINT 0
	PUSHINT 1
	;; return
	BLKSWAP 6, 3
	BLKDROP 6
	RET
}
IFJMP
;; msg_body_slice
;; stack=6
PUSH s2
LDU 32
POP s4
;; decl: func_id
;; if
;; bounced
;; stack=7
PUSH s2
PUSHINT 1
;; ==
EQUAL
PUSHCONT {
	PUSHINT $onBounce$
	;; decl: on_bounce_id
	;; func_id
	;; stack=8
	PUSH s1
	;; on_bounce_id
	;; stack=9
	PUSH s1
	PUSHINT 0
	;; return
	BLKSWAP 8, 3
	BLKDROP 8
	RET
}
IFJMP
;; msg_body_slice
;; stack=7
PUSH s3
;; func_id
;; stack=8
PUSH s1
PUSHINT 0
;; return
BLKSWAP 7, 3
BLKDROP 7
RET

.internal-alias :main_external,        -1
.internal	:main_external
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: main_external_body
;; param: 
;; param: msg_balance
;; param: msg_cell
;; param: msg_body_slice
PRINTSTR main_external
;; msg_cell
;; stack=4
PUSH s1
PUSHCONT { ; get_src_addr_and_bounce__inline
	;; param: msg_cell
	PRINTSTR get_src_addr
	;; msg_cell
	;; stack=1
	DUP
	CTOS
	;; decl: msg_slice
	;; if
	;; msg_slice
	;; stack=2
	DUP
	LDU 1
	POP s2
	PUSHINT 0
	;; !=
	NEQ
	PUSHCONT {
		PUSHINT 0
		PUSHINT 0
		;; return
		BLKSWAP 2, 2
		BLKDROP 2
		RET
	}
	IFJMP
	;; msg_slice
	;; stack=2
	DUP
	PUSHINT 2
	SDSKIPFIRST
	NIP
	;; msg_slice
	;; stack=2
	DUP
	LDU 1
	POP s2
	;; decl: bounced
	;; msg_slice
	;; stack=3
	PUSH s1
	PUSHINT 11
	PUSHCONT { ; get_address_from_slice_inline
		;; param: slice
		;; param: offset
		;; slice
		;; stack=2
		PUSH s1
		;; offset
		;; stack=3
		PUSH s1
		SDSKIPFIRST
		POP s2
		;; slice
		;; stack=2
		PUSH s1
		LDU 256
		POP s3
		;; return
		NIP
		NIP
		RET
	}
	CALLX
	;; decl: addr
	PRINTSTR get_src_addr_en
	;; bounced
	;; stack=4
	PUSH s1
	;; addr
	;; stack=5
	PUSH s1
	;; return
	BLKSWAP 4, 2
	BLKDROP 4
	RET
}
CALLX
NIP
;; decl: src_addr
;; msg_body_slice
;; stack=5
PUSH s1
PUSHCONT { ; get_msg_pubkey_inline
	;; param: msg_slice
	PRINTSTR get_msg_pubkey
	PUSHINT 0
	;; decl: pubKey
	;; if
	;; msg_slice
	;; stack=2
	PUSH s1
	SREMPTY
	PUSHCONT {
		;; m_addReturnFlag = 1
		PRINTSTR get_msg_pubkey3
		PUSHINT 0
		;; return
		NIP
		NIP
		PUSHINT 1 ; return
		RET
	}
	PUSHCONT {
		;; m_addReturnFlag = 1
		;; msg_slice
		;; stack=2
		PUSH s1
		LDREFRTOS
		;; decl: rest_msg_slice
		;; decl: slice
		;; if
		;; slice
		;; stack=4
		DUP
		SDEMPTY
		PUSHCONT {
			;; m_addReturnFlag = 1
			PRINTSTR get_msg_pubkey3
			PUSHINT 0
			;; return
			XCHG s4
			BLKDROP 4
			PUSHINT 1 ; return
			RET
		}
		IFJMP
		;; slice
		;; stack=4
		DUP
		PUSHINT 512
		PUSHCONT { ; get_address_from_slice_inline
			;; param: slice
			;; param: offset
			;; slice
			;; stack=2
			PUSH s1
			;; offset
			;; stack=3
			PUSH s1
			SDSKIPFIRST
			POP s2
			;; slice
			;; stack=2
			PUSH s1
			LDU 256
			POP s3
			;; return
			NIP
			NIP
			RET
		}
		CALLX
		;; assign pubKey
		POP s3
		;; rest_msg_slice
		;; stack=4
		PUSH s1
		HASHSU
		;; decl: hash
		;; hash
		;; stack=5
		DUP
		;; slice
		;; stack=6
		PUSH s2
		;; pubKey
		;; stack=7
		PUSH s5
		CHKSIGNU
		;; decl: checkSig
		;; checkSig
		;; stack=6
		DUP
		THROWIFNOT 40
		;; drop locals
		BLKDROP 4
		FALSE
	}
	IFELSE
	IFRET
	PRINTSTR get_msg_pubkey2
	;; pubKey
	;; stack=2
	DUP
	;; return
	NIP
	NIP
	RET
}
CALLX
;; decl: pubKey
;; if
;; !
;; msg_body_slice
;; stack=6
PUSH s2
SREMPTY
NOT
PUSHCONT {
	;; msg_body_slice
	;; stack=6
	PUSH s2
	LDREF
	NIP
	;; assign msg_body_slice
	POP s3
}
IF
;; msg_balance
;; stack=6
PUSH s4
;; src_addr
;; stack=7
PUSH s2
;; pubKey
;; stack=8
PUSH s2
PUSHCONT { ; store_signature_inline
	;; param: msg_balance
	;; param: src_addr
	;; param: sign
	PRINTSTR store_sig
	TUPLE 0
	;; decl: tuple
	;; sign
	;; stack=4
	PUSH s1
	TPUSH
	;; src_addr
	;; stack=4
	PUSH s2
	TPUSH
	;; msg_balance
	;; stack=4
	PUSH s3
	TPUSH
	PUSHCTR c7
	;; decl: c7
	;; tuple
	;; stack=5
	PUSH s1
	TPUSH
	;; c7
	;; stack=5
	DUP
	POPCTR c7
	PRINTSTR store_sig_end
	BLKDROP 5
}
CALLX
;; if
;; msg_body_slice
;; stack=6
PUSH s2
SDEMPTY
PUSHCONT {
	PRINTSTR msg_is_empty
	;; return
	BLKDROP 6
	RET
}
IFJMP
;; msg_body_slice
;; stack=6
PUSH s2
LDU 32
POP s4
;; decl: func_id
;; msg_body_slice
;; stack=7
PUSH s3
LDU 64
POP s5
;; decl: msg_timestamp
PUSHCONT { ; previous_message_info_inline
	;; ret param: timestamp
	PUSHINT 0
	;; ret param: interval
	PUSHINT 0
	PRINTSTR prev_time
	PUSHROOT
	CTOS
	;; decl: c4
	;; c4
	;; stack=3
	DUP
	LDDICT
	POP s2
	;; decl: dict
	PUSHINT 128
	PUSHINT 2
	;; dict
	;; stack=6
	PUSH s2
	PUSHINT 64
	DICTUGET
	PUSHCONT { 
		NIP
	}
	PUSHCONT {
		NEWC      ; valueBits builder
		PUSHINT 0 ; valueBits builder 0
		XCHG S2   ; 0 builder valueBits
		STUX      ; builder
		ENDC      ; cell
		CTOS      ; default_value
	}
	IFELSE
	;; decl: slice
	;; slice
	;; stack=5
	DUP
	LDU 64
	POP s2
	;; assign timestamp
	POP s5
	;; slice
	;; stack=5
	DUP
	LDU 64
	POP s2
	;; assign interval
	POP s4
	;; if
	;; timestamp
	;; stack=5
	PUSH s4
	PUSHINT 0
	;; ==
	EQUAL
	PUSHCONT {
		PUSHINT 60000
		;; assign interval
		POP s4
	}
	IF
	PRINTSTR prev_time_end
	;; returning named params
	BLKDROP 3
}
CALLX
;; decl: previous_message_timestamp
;; decl: interval
NOW
;; decl: mynow
PRINTSTR replay_prot
;; if
;; previous_message_timestamp
;; stack=11
PUSH s2
;; msg_timestamp
;; stack=12
PUSH s4
;; <
LESS
;; msg_timestamp
;; stack=12
PUSH s4
;; mynow
;; stack=13
PUSH s2
PUSHINT 1000
;; *
MUL
;; interval
;; stack=14
PUSH s4
;; +
ADD
;; <
LESS
;; &&
AND
PUSHCONT {
	ACCEPT
	;; msg_timestamp
	;; stack=11
	PUSH s3
	;; interval
	;; stack=12
	PUSH s2
	PUSHCONT { ; set_previous_message_info_inline
		;; param: timestamp
		;; param: interval
		PUSHROOT
		CTOS
		;; decl: c4
		;; c4
		;; stack=3
		DUP
		LDDICT
		POP s2
		;; decl: dict
		NEWC
		;; decl: builder
		;; timestamp
		;; stack=5
		PUSH s4
		STUR 64
		;; interval
		;; stack=5
		PUSH s3
		STUR 64
		;; builder
		;; stack=5
		DUP
		ENDC
		CTOS
		PUSHINT 2
		;; dict
		;; stack=7
		PUSH s3
		PUSHINT 64
		DICTUSET
		POP s2
		NEWC
		;; decl: c4_builder
		;; dict
		;; stack=6
		PUSH s2
		;; c4_builder
		;; stack=7
		PUSH s1
		STDICT
		NIP
		;; c4_builder
		;; stack=6
		DUP
		ENDC
		POPROOT
		BLKDROP 6
	}
	CALLX
	;; msg_body_slice
	;; stack=11
	PUSH s7
	;; func_id
	;; stack=12
	PUSH s5
	BLKSWAP 11, 2
	BLKDROP 11
	JMP 1
	;; return
	BLKDROP 11
	RET
}
IFJMP
THROW 124
BLKDROP 11

.globl	set_previous_message_info_inline
.type	set_previous_message_info_inline, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: set_previous_message_info_inline
;; param: timestamp
;; param: interval
PUSHROOT
CTOS
;; decl: c4
;; c4
;; stack=3
DUP
LDDICT
POP s2
;; decl: dict
NEWC
;; decl: builder
;; timestamp
;; stack=5
PUSH s4
STUR 64
;; interval
;; stack=5
PUSH s3
STUR 64
;; builder
;; stack=5
DUP
ENDC
CTOS
PUSHINT 2
;; dict
;; stack=7
PUSH s3
PUSHINT 64
DICTUSET
POP s2
NEWC
;; decl: c4_builder
;; dict
;; stack=6
PUSH s2
;; c4_builder
;; stack=7
PUSH s1
STDICT
NIP
;; c4_builder
;; stack=6
DUP
ENDC
POPROOT
BLKDROP 6

.globl	previous_message_info_inline
.type	previous_message_info_inline, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: previous_message_info_inline
;; ret param: timestamp
PUSHINT 0
;; ret param: interval
PUSHINT 0
PRINTSTR prev_time
PUSHROOT
CTOS
;; decl: c4
;; c4
;; stack=3
DUP
LDDICT
POP s2
;; decl: dict
PUSHINT 128
PUSHINT 2
;; dict
;; stack=6
PUSH s2
PUSHINT 64
DICTUGET
PUSHCONT { 
	NIP
}
PUSHCONT {
	NEWC      ; valueBits builder
	PUSHINT 0 ; valueBits builder 0
	XCHG S2   ; 0 builder valueBits
	STUX      ; builder
	ENDC      ; cell
	CTOS      ; default_value
}
IFELSE
;; decl: slice
;; slice
;; stack=5
DUP
LDU 64
POP s2
;; assign timestamp
POP s5
;; slice
;; stack=5
DUP
LDU 64
POP s2
;; assign interval
POP s4
;; if
;; timestamp
;; stack=5
PUSH s4
PUSHINT 0
;; ==
EQUAL
PUSHCONT {
	PUSHINT 60000
	;; assign interval
	POP s4
}
IF
PRINTSTR prev_time_end
;; returning named params
BLKDROP 3

.globl	my_pubkey
.type	my_pubkey, @function
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function: my_pubkey
PRINTSTR my_pubkey
PUSHROOT
CTOS
;; decl: slice_dict
;; slice_dict
;; stack=1
DUP
LDDICT
POP s2
;; decl: persistentDataDict
PUSHINT 0
;; persistentDataDict
;; stack=3
PUSH s1
PUSHINT 64
DICTUGET
THROWIFNOT 100
;; decl: slice_pubkey
;; slice_pubkey
;; stack=3
DUP
LDU 256
POP s2
;; decl: pubkey
;; slice_pubkey
;; stack=4
PUSH s1
ENDS
NULL
POP s2
PRINTSTR my_pubkey_end
;; pubkey
;; stack=4
DUP
;; return
XCHG s4
BLKDROP 4
RET

